/*
 * Copyright 2014 University of Aveiro
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package edduarte.protbox.core;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.io.File;
import java.io.Serializable;

/**
 * A Protbox Pair refers to a set of two folders: the Shared folder and the Prot folder.
 * Users must define one-to-one associations between Shared folders and the local folders
 * containing the relevant files to protect, which we call Prot folders and may be located
 * anywhere in the host file system.
 * <p>
 * A key is generated and maintained for each Protbox Pair (called Pair key). Each Pair key
 * is either (i) randomly generated by Protbox (when the first protected file is created in
 * the corresponding Shared folder) or (ii) imported by Protbox from other users sharing the
 * corresponding Shared folder (when the Shared folder is not empty).
 *
 * @author Ed Duarte (<a href="mailto:edmiguelduarte@gmail.com">edmiguelduarte@gmail.com</a>)
 * @version 2.0
 */
public class PbxPair implements Serializable {

    private static final long serialVersionUID = 1L;

    private final String sharedFolderPath;

    private final String pairAlgorithm;

    private final SecretKey pairKey;

    private final SecretKey integrityKey;

    private String protFolderPath;


    public PbxPair(final String sharedFolderPath,
                   final String protFolderPath,
                   final String cipherAlgorithm,
                   final SecretKey cipherKey/*,
                   final SecretKey integrityKey*/) {
        File sharedPathFile = new File(sharedFolderPath);
        File protPathFile = new File(protFolderPath);
        this.sharedFolderPath = sharedPathFile.getAbsolutePath();
        this.protFolderPath = protPathFile.getAbsolutePath();
        this.pairAlgorithm = cipherAlgorithm;
        this.pairKey = cipherKey;
//        this.integrityKey = integrityKey;
        this.integrityKey = new SecretKeySpec(pairKey.getEncoded(), "HmacSHA512");
    }


    /**
     * Gets the configured Shared shared folder path where the encrypted files will be.
     */
    public String getSharedFolderPath() {
        return sharedFolderPath;
    }


    /**
     * Gets the configured Shared shared folder where the encrypted files will be.
     */
    public File getSharedFolderFile() {
        return new File(sharedFolderPath);
    }


    /**
     * Gets the configured Prot folder path where every file from the Shared folder will be stored in decrypted form.
     */
    public String getProtFolderPath() {
        return protFolderPath;
    }


    /**
     * Sets the configured Shared shared folder path where the encrypted files will be.
     */
    public void setProtFolderPath(String protFolderPath) {
        this.protFolderPath = protFolderPath;
    }


    /**
     * Gets the configured Prot folder where every file from the Shared folder will be stored in decrypted form.
     */
    public File getProtFolderFile() {
        return new File(protFolderPath);
    }


    /**
     * Simple access to the algorithm used by this Pair. This is used to instantiate the Cipher
     * per execution, since the Cipher object cannot be serialized.
     */
    public String getPairAlgorithm() {
        return pairAlgorithm;
    }


    /**
     * Gets the secret key used by this Pair for encryption and decryption of files' contents and names.
     */
    public SecretKey getPairKey() {
        return pairKey;
    }


    /**
     * Gets the secret key used by this Pair for integrity checking of files' data.
     */
    public SecretKey getIntegrityKey() {
        return integrityKey;
    }


    @Override
    public int hashCode() {
        return sharedFolderPath.hashCode() * protFolderPath.hashCode();
    }


    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }

        if (this == obj) {
            return true;
        }

        if (obj instanceof PbxPair) {
            PbxPair otherPair = (PbxPair) obj;
            return sharedFolderPath.equalsIgnoreCase(otherPair.sharedFolderPath) &&
                    protFolderPath.equalsIgnoreCase(otherPair.protFolderPath);
        }

        return false;
    }
}
